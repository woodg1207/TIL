## SQLD_sql_hierarchical_query

### 1. 계층형 질의

- 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해서 계층형 질의(Hierarchical Query)를 사용한다. 
- 계층형 데이터란 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 말한다.

### 2. Oracle 계층형 질의

```mysql
select...
from table_a
where 조건 and 조건 ...
start with 조건
connect by [nocycle] 조건 and 조건 ...
[order siblings by column, column, ...]
```

- START WITH절은 계층 구조 전개의 시작 위치를 지정하는 구문이다. 
  - 즉, 루트 데이터를 지정한다.(액세스) - 
- CONNECT BY절은 다음에 전개될 자식 데이터를 지정하는 구문이다. 
  - 자식 데이터는 CONNECT BY절에 주어진 조건을 만족해야 한다.(조인) 
  - PRIOR : CONNECT BY절에 사용되며, 현재 읽은 칼럼을 지정한다. 
    - `PRIOR 자식 = 부모` 형태를 사용하면 계층구조에서 자식 데이터에서 부모 데이터(자식 → 부모) 방향으로 전개하는 순방향 전개를 한다.
    - `PRIOR 부모 = 자식` 형태를 사용하면 반대로 부모 데이터에서 자식 데이터(부모 → 자식) 방향으로 전개하는 역방향 전개를 한다. 
    - NOCYCLE : 데이터를 전개하면서 이미 나타났던 동일한 데이터가 전개 중에 다시 나타난다면 이것을 가리켜 사이클(Cycle)이 형성되었다라고 말한다. 사이클이 발생한 데이터는 런타임 오류가 발생한다. 
    - 그렇지만 NOCYCLE를 추가하면 사이클이 발생한 이후의 데이터는 전개하지 않는다. 
- ORDER SIBLINGS BY : 형제 노드(동일 LEVEL) 사이에서 정렬을 수행한다. 
- WHERE : 모든 전개를 수행한 후에 지정된 조건을 만족하는 데이터만 추출한다.(필터링)

##### orcle은 가상 칼럼을 제공한다

|                    | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| level              | 루트 데이터면 1, 하위는 2, `리프`까지 1씩 증가               |
| connect_by_isleaf  | 전개 과정에서 해당 데이터가 `리프`면 1, 아니면 0             |
| connect_by_iscycle | 전개 과정에서 자식을 갖는데, 해당 데이터가 조상으로 존재하면 1, 아니면 0. cycle 옵션을 사용했을때만 가능, 여기서 조상이란 자신으로부터 루트까지의 경로에 존재하는 데이터 |



##### ex) 

- 결과 데이터를 들여쓰기 하기 위해서 LPAD 함수를 사용하였다.

- ```mysql
  SELECT LEVEL, LPAD(' ', 4 * (LEVEL-1)) || 사원 사원, 관리자, CONNECT_BY_ISLEAF ISLEAF 
  FROM 사원 
  START WITH 관리자 IS NULL 
  CONNECT BY PRIOR 사원 = 관리자;
  ```

- ```mysql
  LEVEL 사원 관리자 ISLEAF 
  ----- -------- ----- ------ 
  1 A 0 
  2 B A 1 
  2 C A 0 
  3 D C 1 
  3 E C 1
  ```

  - A는 루트 데이터이기 때문에 레벨이 1이다. 
  - A의 하위 데이터인 B, C는 레벨이 2이다. 
  - 그리고 C의 하위 데이터인 D, E는 레벨이 3이다. 
  - 리프 데이터는 B, D, E이다. 관리자 → 사원 방향을 전개이기 때문에 순방향 전개이다. [그림 Ⅱ-2-8]은 계층형 질의에 대한 논리적인 실행 모습이다.

- 다음 예제는 사원 'D'로부터 자신의 상위관리자를 찾는 역방향 전개의 예이다.

```mysql
SELECT LEVEL, LPAD(' ', 4 * (LEVEL-1)) || 사원 사원, 관리자, CONNECT_BY_ISLEAF ISLEAF FROM 사원 
START WITH 사원 = 'D' 
CONNECT BY PRIOR 관리자 = 사원;
```

```mysql
LEVEL 사원 관리자 ISLEAF 
----- --------- ----- ----- 
1 D C 0 
2 C A 0 
3 A 1
```

- 역방향 전개이기 때문에 하위 데이터에서 상위 데이터로 전개된다. 
- 결과를 보면 내용을 제외하고 표시 형태는 순방향 전개와 동일하다. 
- D는 루트 데이터이기 때문에 레벨이 1이다. D의 상위 데이터인 C는 레벨이 2이다. 
- 그리고 C의 상위 데이터인 A는 레벨이 3이다. 리프 데이터는 A이다. 
- 루트 및 레벨은 전개되는 방향에 따라 반대가 됨을 알 수 있다.

| 함수                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| sys_connect_by_path | 루트 데이터 부터 현재 전개할 데이터까지의 경로를 표기. <br />사용법 : `sys_connect_by_path(칼럼, 경로 분리자)` |
| connect_by_root     | 현재 전개할 데이터의 루트 데이터를 표시<br />사용법 : `connect_by_root 칼럼` |

```mysql
SELECT CONNECT_BY_ROOT 사원 루트사원, SYS_CONNECT_BY_PATH(사원, '/') 경로, 사원, 관리자 FROM 사원 
START WITH 관리자 IS NULL 
CONNECT BY PRIOR 사원 = 관리자
```

```mysql
루트사원 경로 사원 관리자 
------- ------- ---- ----- 
A /A A 
A /A/B B A 
A /A/C C A 
A /A/C/D D C 
A /A/C/E E C
```

- START WITH를 통해 추출된 루트 데이터가 1건 이기 때문에 루트사원은 모두 A이다. 경로는 루트로부터 현재 데이터까지의 경로를 표시한다. 예를 들어, D의 경로는 A → C → D 이다.